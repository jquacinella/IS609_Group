---
title: "Documentation"
author: "Aaron Palumbo"
date: "Monday, December 08, 2014"
output: html_document
---
```{r include}
library(ggplot2)
library(reshape2)
library(plyr)
```

Objective: Generate figures to help explain game theory analysis

# Assumptions and Terms

We want to take a look at a tennis match from the perspective of game theory. In order to do this we will make some simplifying assumptions.

1. The main factor in determining the winner of a point is where the serve is placed
2. There are two distince scenarios that present two distince games:

* Deuce-court
    + Server has choice of serving left or right
    + Receiver has choice of guessing left or right
    
![Deuce court](serve_deuce_court.png)

* Ad-court
    + Server has choice of serving left or right
    + Receiver has choice of guessing left or right

![Ad-court](serve_ad_court.png)

The option that is ignored is the center serve (from either court), since that rarely occurs.

For each game we would expect there to be an equilibrium point. For example, the deuce-court serve might look like this:


```{r model_params}

# Model parameters
# Probabilities for server winning point
# serve: sv, receive: rc, left: lf, right: rt
# e.g.: sv_lf.rc_rt: serve_left.receive_right

model.df <- data.frame(prob    = c( 0.9,          0.65,          0.7,           0.80),
                       sv      = c( 0.0,          0.0,           1.0,           1.0),
                       rc      = c( 0.0,          1.0,           0.0,           1.0),
                       desc.sv = c("Serve Left", "Serve Left",  "Serve Rigth", "Serve Right"),
                       desc.rc = c("Guess Left", "Guess Right", "Guess Left",  "Guess Right"),
                       hj      = c( 0.0,          0.0,           1.1,           1.1),
                       vj      = c(-0.3,          1.3,           1.3,          -0.3))

model.df$desc <- paste(model.df$desc.sv, model.df$desc.rc, sep="\n")

# Conflict Matrix:
# |             | Receive left | Receive Right |
# |-------------|:------------:|:-------------:|
# |  Serve Left |  sv_lf.rc_lf |  sv_lf.rc_rt  |
# | Serve Right |  sv_rt.rc_lf |  sv_rt.rc_rt  |

conflict.matrix <- matrix(data=model.df$prob, nrow = 2, byrow = TRUE)

# Equilibrium point
d.r1 <- abs(diff(conflict.matrix[1,]))
d.r2 <- abs(diff(conflict.matrix[2,]))
d.c1 <- abs(diff(conflict.matrix[,1]))
d.c2 <- abs(diff(conflict.matrix[,2]))
sv_rt.eq <- d.r1 / (d.r1 + d.r2)
rc_rt.eq <- d.c1 / (d.c1 + d.c2)

# Expected value of game (server)
ex.sv <- as.numeric(conflict.matrix[,1]  %*% c(1 - sv_rt.eq, sv_rt.eq))
```

```{r classic_game_theory_figure, echo=FALSE, fig.align='center', fig.width=8, fig.height=6}

# Plotting parameters
b <- (1:5)*20/100
ann_size <- 4

# Generate Plot
p <- ggplot(model.df, aes(x=sv, y=prob, label=desc)) + 
  geom_rect(aes(xmin=0, xmax=1, ymin=0, ymax=1), fill="white", alpha=.2) + 
  geom_line(aes(group=rc, color=desc.rc), size=1.5) +
  geom_point(size = 4) +
  geom_text(aes(hjust=hj, vjust=vj)) +
  annotate("segment", x=0.05,    xend=sv_rt.eq, y=ex.sv, yend=ex.sv, linetype=2) + 
  annotate("segment", x=sv_rt.eq, xend=sv_rt.eq, y=0,  yend=ex.sv, linetype=2) +
  annotate("text", label=round(ex.sv, 2), x=0, y=ex.sv, hjust=.5) +
  annotate("text", label=round(sv_rt.eq, 2), x=sv_rt.eq, y=0, vjust=1.5) +
  ggtitle("Deuce-court Serve") +
  xlab("Probability Server serves right") + 
  scale_x_continuous(breaks=b) +
  ylab("Probability point won by Server") +
  scale_y_continuous(breaks=b) +
  theme(plot.title = element_text(face="bold", size=20)) + 
  scale_color_manual(name = "Receiver actions",
                     values = c("#1b9e77", "#d95f02"))

# Turn off clipping
gt <- ggplot_gtable(ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"

# Display
plot(gt)

```

# Validate Chi Squared Calculation

From paper:

Match 82: Wimbldn, Conners, McEnroe  

Conners, Ad:   
  Serves: L - 32, R - 46, Total - 48  
  Points: L - 16, R - 32  
  
Pearson statisitc = 3.052  
p-value = 0.081  

Let's make sure I can match this calculation:  

|         | Win    |  Lose |        |
|---------|--------|-------|--------|
| Serve L | **16** | 16    | **32** |
| Serve R | 32     | 14    | **46** |
|         | 48     | 30    | **78** |

```{r}
values <- c(16, 16, 32, 14)
m <- matrix(values, nrow=2, byrow=TRUE)
chisq.test(m, correct=FALSE)
```

These values match the paper

# Simulation

## Simulation function
Create a funtion to simulate results of a specified number of games

```{r sim_function}

simulate.points <- function(probs, sv_rt.act, rc_rt.act, n.pts){  
  # ==============================================================
  # Unroll probabilities    # Probability serer wins when:
                            # |--------------|-------------------|
                            # | Server       | Receiver          |
                            # |--------------|-------------------|
  sv_lf.rc_lf <- probs[1]   # | Serves left  | Guesses left      |
  sv_lf.rc_rt <- probs[2]   # | Serves left  | Guesses right     |
  sv_rt.rc_lf <- probs[3]   # | Serves right | Guesses left      |
  sv_rt.rc_rt <- probs[4]   # | Serves right | Guesses right     |
  
  # sv_rt.act = Probability server serves right
  # rc_rt.act = Probability receiver guesses right
  # ** these do not have to equal equilibrium values
  
  # n.pts = number of points to simulate
  # ==============================================================
  
  # Simulate serves and receive-guesses
  # Serve left = 0, Serve right = 1
  # Guess left = 0, Guess right = 1
  sv <- rbinom(n.pts, 1, sv_rt.act)
  rc <- rbinom(n.pts, 1, rc_rt.act)
  
  # Simulate winner of point based on given probabilities
  # sv.wins = 1, server wins
  # sv.wins = 0, server loses
  point.results <- data.frame(sv=sv, rc=rc, sv.wins=NA)
  
  # Create filters for the four combinations:
  f.sv_lf.rc_lf <- sv == 0 & rc == 0     # Serve left  - Guess left
  f.sv_lf.rc_rt <- sv == 0 & rc == 1     # Serve left  - Guess right
  f.sv_rt.rc_lf <- sv == 1 & rc == 0     # Serve right - Guess left
  f.sv_rt.rc_rt <- sv == 1 & rc == 1     # Serve right - Guess right
  
  # Simulate results:                            Number of points       Prob of winning
  point.results$sv.wins[f.sv_lf.rc_lf] <- rbinom(sum(f.sv_lf.rc_lf), 1, sv_lf.rc_lf)
  point.results$sv.wins[f.sv_lf.rc_rt] <- rbinom(sum(f.sv_lf.rc_rt), 1, sv_lf.rc_rt)
  point.results$sv.wins[f.sv_rt.rc_lf] <- rbinom(sum(f.sv_rt.rc_lf), 1, sv_rt.rc_lf)
  point.results$sv.wins[f.sv_rt.rc_rt] <- rbinom(sum(f.sv_rt.rc_rt), 1, sv_rt.rc_rt)
  
  return(point.results)
}

```

## Test simulation

```{r test_sim}
# Set parameters
n.points <- 10

use.eq <- TRUE

if(use.eq){
  serve_right.actual <- sv_rt.eq
  receive_right.actual <- rc_rt.eq
} else{
  serve_right.actual <- 0
  receive_right.actual <- 0
}

# Run simulation
sim.test <- simulate.points(model.df$prob, serve_right.actual, receive_right.actual, n.points)

# Take a look at the results: If playing at equilibrium these should be equal
print(c("Use equilibrium values: ", use.eq))
print(c("Probability server wins when serving right: ", mean(sim.test$sv.wins[sim.test$sv == 1])))
print(c("Probability server wins when serving left: ",  mean(sim.test$sv.wins[sim.test$sv == 0])))

print(c("Probability server wins overall: ", mean(sim.test$sv.wins)))

# Use the chi squared test to determine if Serve Direction is independent of winning point

# |------------------|-------------------|-------------------|
# |                  | Point lost        | Point Won         |
# |------------------|-------------------|-------------------|
# | Serve Left       | count(lost|left)  | count(won|left)   |
# |------------------|-------------------|-------------------|
# | Serve Right      | count(lost|right) | count(won|right)  |
# |------------------|-------------------|-------------------|

m <- table(sim.test$sv, sim.test$sv.wins)

chisq.test(m, correct=FALSE)
```

# Use simulation to look at game space

Let's look at a heat map of the servers expected win ratio for all combinations of serving left or right and all combinations of the receiver guessing left or right.

```{r sim_helper}
# ==============================================================================
# functions to return heat map color value
#
# Inputs:
#   probs: vector of probability server wins for all serve receive combinations
#   sv_rt.act: probability server serves right
#   rc_rt.act: probability receiver guesses right
#   n.pts: number of points to play
#
# Returns:
#   list$ev:  probability server wins point
#   list$chi: chi squared value of serve vs wins
#   list$pv:  p-value of serve vs wins
# ==============================================================================

sim.return <- function(probs, sv_rt.act, rc_rt.act, n.pts){
  # Simulation
  r <- simulate.points(probs, sv_rt.act, rc_rt.act, n.pts)
  
  # Calculations
  m <- table(r$sv, r$sv.wins)
  options(warn=-1)                          # suppress warnings from chisq.test
  chi.test <- chisq.test(m, correct=FALSE)
  options(warn=0)                           # turn warnings back on
  
  # Return list
  return.list <- list(ev = mean(r$sv.wins),
                      chi = chi.test$statistic,
                      pv = chi.test$p.value)
  
  return(return.list)
}

```

```{r sim_helper_test, echo=FALSE, eval=FALSE}
# Test of sim.return
test.list <- sim.return(model.df$prob, sv_rt.eq, rc_rt.eq, 10)
test.list
```

```{r run_simulation}
#------------------------------------------------------------
# Simulation parameters

per.side <- 40 # target is 40
increment <- 1 / per.side

# Number of games to simulate for each point in the grid
# Different values depending on objective
n.trials <- list("full"        = c(100, 1000, 10000, 50000),
                 "partial"     = c(100, 1000, 5000),
                 "quick.multi" = c(100, 150, 200), 
                 "quick.one"   = c(100),
                 "long.one"    = c(50000))                     #~2 minutes
#------------------------------------------------------------
                 
# Initialize result data frame
size.effect = data.frame()

# Run simulation <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
for(pts in n.trials$full){
  
  # Create simulation grid
  sv.act <- seq(0, 1, increment)
  rc.act <- seq(0, 1, increment)
  
  df <- data.frame(expand.grid(sv.act, rc.act))
  names(df) <- c("sv.act", "rc.act")
  
  df$ev <- NA
  df$chi <- NA
  df$pv <- NA
  df$points <- pts
  
  # Run simulation for each point in grid
  for(r in 1:nrow(df)){
    sim.list <- sim.return(model.df$prob, df$sv.act[r], df$rc.act[r], pts)
    df$ev[r] <- sim.list$ev
    df$chi[r] <- sim.list$chi
    df$pv[r] <- sim.list$pv
  }
  
#   df <- ddply(df, .(sv.act, rc.act), transform,
#               sim = sim.return(model.df$prob, sv.act, rc.act, pts))
#   
#   df <- ddply(df, x(sv.act, rc.act), transform,
#               points = pts,
#               ev = sim$ev,
#               chi = sim$chi,
#               pv = sim$pv)
  
  print("Joining simulation of points =")
  print(pts)
  size.effect <- join(size.effect, df, type="full")
}
```



```{r fig.width=8, fig.height=2.5}

# Bin ev for plotting
ev.min <- min(size.effect$ev) - 0.001
ev.max <- max(size.effect$ev)
b <- c(seq(from=ev.min,        to=ex.sv - 0.005, length.out=5), 
       seq(from=ex.sv + 0.005, to=ev.max,        length.out=5))

size.effect$ev.bin <- cut(size.effect$ev, breaks=b)

# Plot
ggplot(size.effect, aes(x=rc.act, y=sv.act)) + 
  geom_tile(aes(fill=ev.bin)) + 
  geom_vline(xintercept=rc_rt.eq, color="red") + 
  geom_hline(yintercept=sv_rt.eq, color="red") +
  facet_grid(. ~ points) +
  scale_fill_brewer(palette = "YlGnBu")

```

We can see that equilibrium play is achieved when the server serves 75% right and the receiver guesses 50% right. We can also see that we need to look at a lot of games to reduce noise.

Since we can't observe which way the receiver is guessing we will use the pearson statistic as a surrogate. Looking at the chi squared value in the same manner we have:

```{r fig.width=8, fig.height=2.5}

ggplot(size.effect, aes(x=rc.act, y=sv.act)) + 
  geom_tile(aes(fill=pv)) + 
  geom_vline(xintercept=rc_rt.eq, color="red") + 
  geom_hline(yintercept=sv_rt.eq, color="red") + 
  facet_grid(. ~ points)
#   scale_fill_brewer(palette = "YlGnBu")
  

```

